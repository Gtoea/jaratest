# -*- coding: utf-8 -*-
"""
This script takes the database generated by final_database_generation.py and creates summary plots 
for amplitude modulated data comparison.

This script plots:
1. Highest Onset Rate: Rate that gave the highest onset (0-50ms after stimulus presentation) response
2. Highest Sustained Rate: Rate that gave the highest sustained (50-100ms after stimulus presentation) 
response
3. highest synchronization: Highest rate that cell synchronizes to by Rayleigh test
4. Percent Synchronization: Percentage of cells that synchronize in each group
5. Rate Descrimination Accuracy: Ability of a cell to descriminate ampitude modulation rates (value 
between 0 and 1, where 1 represents perfect descrimination)
6. Phase Descrimination Accuracy: Ability of a cell to determine the phase of different amplitude 
modulation rates (value between 0 and 1, where 1 represents perfect determination)
"""
import os
import figparams
import studyparams
import numpy as np
from jaratoolbox import celldatabase
from jaratoolbox import settings
from jaratoolbox import extraplots
from matplotlib import pyplot as plt
import matplotlib.gridspec as gridspec
from scipy import stats

# TODO: Update to work with database naming changes
# TODO: Update to work with database_add_am_stats.py columns

# ========================== Utility Functions ==========================

np.random.seed(7) # Seed for jitter function

# Creates variation in point spacing
def jitter(arr, dotSpread):
    jitter = (np.random.random(len(arr))-0.5)*dotSpread
    jitteredArr = arr + jitter
    return jitteredArr

dotSpread = 0.2 # Value for spread of points on figures (higher value equals greater spread) 

# ========================== Run Mode ==========================

# Set to 1 to run for one test animal, set to 0 to run for all animals in study 
ONE_SUBJECT = 1

if ONE_SUBJECT:
    d1mice = studyparams.SINGLE_MOUSE
    outputDirectory = figparams.FIGURE_OUTPUT_DIR 
    inputDirectory = os.path.join(settings.DATABASE_PATH, studyparams.STUDY_NAME,
                                   'astrpi_{}_am.h5'.format(d1mice[0]))
    figFilename = 'figure_{}'.format(d1mice[0])
else:
    d1mice = studyparams.ASTR_D1_CHR2_MICE
    outputDirectory = figparams.FIGURE_OUTPUT_DIR 
    inputDirectory = os.path.join(settings.DATABASE_PATH, studyparams.STUDY_NAME,
                                   'astrpi_all_cells_am.h5')
    figFilename = 'figure_{}'.format(studyparams.DATABASE_NAME)

# A value of 1 plots the given comparison, 0 does not 
HIGHESTONSET = 1 # 
HIGHESTSUSTAINED = 0 # 
HIGHESTSYNC = 0 # 
PERCENTSYNC = 0 # 
RATEDESCRIM= 0 # 
PHASEDECRIM = 0 # 

# Loads database for plotting 
db = celldatabase.load_hdf(inputDirectory)

# Filters only cells that have an AM response
db = db.query('AMBestRateOnset * 0 == 0')

# ========================== Figure Parameters ========================== 

# Figure size
figSize = [12, 8] 

# Colors 
colorD1 = figparams.colors['D1']
colornD1 = figparams.colors['nD1']

# Font size
fontSizeLabels = figparams.fontSizeLabels*2
fontSizeTicks = fontSizeLabels*0.5
fontSizePanel = figparams.fontSizePanel*2
fontSizeTitles = figparams.fontSizeTitles*2

# Clears the figure
fig = plt.gcf()
fig.clf()

# creates gridspec object and sets spacing 
gs = gridspec.GridSpec(1, 12)
gs.update(left=0.04, right=0.98, top=0.95, bottom=0.175, wspace=1.1, hspace=0.5)

# Creates axes objects for each plot
axHighestOnset = plt.subplot(gs[0, 0:2])
axHighestSustained = plt.subplot(gs[0, 2:4])
axHighestSync = plt.subplot(gs[0, 4:6])
axPercentSync = plt.subplot(gs[0, 6:8])
axRateDescrim = plt.subplot(gs[0, 8:10])
axPhaseDecrim = plt.subplot(gs[0, 10:12])

# ========================== Highest Onset Rate ==========================

if HIGHESTONSET:
    highestOnsetdb = db

    # Seperates database into D1 and nD1 cells
    highestOnsetD1db = highestOnsetdb.query(studyparams.D1_CELLS)
    highestOnsetnD1db = highestOnsetdb.query(studyparams.nD1_CELLS)
    
    # Creates array of latencies in milliseconds for each cell group 
    highestOnsetD1 = highestOnsetD1db['AMBestRateOnset'] # highestOnset of each D1 cell in milliseconds
    highestOnsetnD1 = highestOnsetnD1db['AMBestRateOnset'] # highestOnset of each nD1 cell in milliseconds
     
    # Calculates the median of the D1 and nD1 latencies 
    highestOnsetMedD1 = highestOnsetD1.median() # Median of D1 cell highestOnset
    highestOnsetMednD1 = highestOnsetnD1.median() # Median of nD1 cell highestOnset
    
    # Calculates statistics for highestOnset between cell type
    zStat, pVal = stats.mannwhitneyu(highestOnsetD1, highestOnsetnD1, alternative='two-sided')

    # Places Pval on plot 
    plt.text(-6.5, 0.9, 'pVal = {:.2f}'.format(pVal))
    
    # Plot label
    axHighestOnset.set_ylabel('Highest Sync Onset (Hz)', fontsize=fontSizeLabels)
    
    ###
    axHighestOnset.set_xticks(range(2))
    axHighestOnset.set_xlim([-0.5, 1.5])
    extraplots.set_ticks_fontsize(axHighestOnset, fontSizeTicks)
    axHighestOnset.set_xticklabels(['D1\n Median={:.2f}'.format(highestOnsetMedD1), 
                                 'nD1\n Median={:.2f}'.format(highestOnsetMednD1)])
    
    ytickLabels = [4, 5.6, 8, 11.3, 16, 22.6, 32, 45.3, 64, 90.5, 128]
    yticks = np.log(ytickLabels)
    yticks = [4, 5.6, 8, 11.3, 16, 22.6, 32, 45.3, 64, 90.5, 128]
    
    axHighestOnset.set_yticks(yticks)
    axHighestOnset.set_yticklabels(ytickLabels)
    
    plt.sca(axHighestOnset)
    spacing = 0.05 # Value for point spacing 
    
    # Plots highestOnset for nD1 cells with a median line
    markers = extraplots.spread_plot(1, highestOnsetnD1, spacing)
    plt.setp(markers, color=colornD1)
    axHighestOnset.plot([-.1,.1], [highestOnsetMedD1, highestOnsetMedD1], color='black', lw=10)
    
    # Plots highestOnset for D1 cells with a median line
    markers = extraplots.spread_plot(0, highestOnsetD1, spacing)
    plt.setp(markers, color=colorD1)
    axHighestOnset.plot([.9,1.1], [highestOnsetMednD1, highestOnsetMednD1], color='black', lw=10)
    
    extraplots.boxoff(axHighestOnset) # Removes box around plot 

# ========================== Highest Sustained Rate ==========================

if HIGHESTSUSTAINED:  
    highestSustaineddb = db.query('')

    # Seperates database into D1 and nD1 cells
    highestSustainedD1db = highestSustaineddb.query(studyparams.D1_CELLS) # D1 cells
    highestSustainednD1db = highestSustaineddb.query(studyparams.nD1_CELLS)
    
    # Creates array of latencies in milliseconds for each cell group 
    highestSustainedD1 = highestSustainedD1db['AMBestRateSustained'] # latency of each D1 cell in milliseconds
    highestSustainednD1 = highestSustainednD1db['AMBestRateSustained'] # latency of each nD1 cell in milliseconds
    
    # Calculates the median of the D1 and nD1 BW10
    BW10MedD1 = BW10D1.median() # Median of D1 cell BW10
    BW10MednD1 = BW10nD1.median() # Median of nD1 cell BW10
    
    # Calculates statistics for BW10 between cell types 
    zStat, pVal = stats.mannwhitneyu(BW10nD1, BW10D1, alternative='two-sided')
    
    # Places Pval on plot 
    plt.text(-8, 1, 'pVal = {:.2f}'.format(BW10pVal))
    
    # Plot label 
    axBW10.set_ylabel('BW10', fontsize=fontSizeLabels)
    
    # Axis spacing and labels  
    axBW10.set_xticks(range(2))
    axBW10.set_xticklabels(['D1\n Median={:.2f} \n n={}'.format(BW10MedD1, len(BW10D1)),
                            'nD1\n Median={:.2f} \n n={}'.format(BW10MednD1, len(BW10nD1))]) 
    axBW10.set_xlim([-0.5, 1.5]) 
    extraplots.set_ticks_fontsize(axBW10, fontSizeTicks) # Sets tick fontsize
    
    # Plots BW10 for nD1 cells with a median line
    pos = jitter(np.ones(len(BW10nD1))*1, dotSpread)
    axBW10.plot(pos, BW10nD1, '.', color=colornD1)
    axBW10.plot([.85,1.15], [BW10MednD1, BW10MednD1], color='black', lw=4, alpha=0.6)
    
    # Plots BW10 for D1 cells with a median line
    pos = jitter(np.ones(len(BW10D1))*0, dotSpread)
    axBW10.plot(pos, BW10D1, '.', color=colorD1)
    axBW10.plot([-.15,.15], [BW10MedD1, BW10MedD1], color='black', lw=4, alpha=0.6) 
    
    extraplots.boxoff(axBW10) # Removes box around plot
   
# ========================== Highest Synchronization ==========================
    
if HIGHESTSYNC:  
    highestSyncdb = db.query('')

    # Seperates database into D1 and nD1 cells
    highestSyncD1db = highestSyncdb.query(studyparams.D1_CELLS) # D1 cells
    highestSyncnD1db = highestSyncdb.query(studyparams.nD1_CELLS)
    
    # Creates array of latencies in milliseconds for each cell group 
    highestSyncD1 = highestSyncD1db['TO ADD'] # latency of each D1 cell in milliseconds
    highestSyncnD1 = highestSyncnD1db['TO ADD'] # latency of each nD1 cell in milliseconds
    
    # Calculates the median of the D1 and nD1 BW10
    BW10MedD1 = BW10D1.median() # Median of D1 cell BW10
    BW10MednD1 = BW10nD1.median() # Median of nD1 cell BW10
    
    # Calculates statistics for BW10 between cell types 
    zStat, pVal = stats.mannwhitneyu(BW10nD1, BW10D1, alternative='two-sided')
    
    # Places Pval on plot 
    plt.text(-8, 1, 'pVal = {:.2f}'.format(BW10pVal))
    
    # Plot label 
    axBW10.set_ylabel('BW10', fontsize=fontSizeLabels)
    
    # Axis spacing and labels  
    axBW10.set_xticks(range(2))
    axBW10.set_xticklabels(['D1\n Median={:.2f} \n n={}'.format(BW10MedD1, len(BW10D1)),
                            'nD1\n Median={:.2f} \n n={}'.format(BW10MednD1, len(BW10nD1))]) 
    axBW10.set_xlim([-0.5, 1.5]) 
    extraplots.set_ticks_fontsize(axBW10, fontSizeTicks) # Sets tick fontsize
    
    # Plots BW10 for nD1 cells with a median line
    pos = jitter(np.ones(len(BW10nD1))*1, dotSpread)
    axBW10.plot(pos, BW10nD1, '.', color=colornD1)
    axBW10.plot([.85,1.15], [BW10MednD1, BW10MednD1], color='black', lw=4, alpha=0.6)
    
    # Plots BW10 for D1 cells with a median line
    pos = jitter(np.ones(len(BW10D1))*0, dotSpread)
    axBW10.plot(pos, BW10D1, '.', color=colorD1)
    axBW10.plot([-.15,.15], [BW10MedD1, BW10MedD1], color='black', lw=4, alpha=0.6) 
    
    extraplots.boxoff(axBW10) # Removes box around plot
   
# ========================== Percent Synchronization ==========================

if PERCENTSYNC:
    # Seperates database into D1 and nD1 cells
    thresholdD1db = db.query(studyparams.D1_CELLS) # D1 cells
    thresholdnD1db = db.query(studyparams.nD1_CELLS) # nD1 cells
    
    # Creates array of threshold values for each cell group
    thresholdD1 = thresholdD1db['thresholdFRA']
    thresholdnD1 = thresholdnD1db['thresholdFRA']
    
    zStat, pVal = stats.mannwhitneyu(thresholdnD1, thresholdD1, alternative='two-sided')
    
    plt.text(-2.6, -0.62, 'pVal = {:.2f}'.format(pVal))
    
    # Takes median of D1 and nD1 thresholds
    thresholdMedD1 = thresholdD1.median()
    thresholdMednD1 = thresholdnD1.median()
    
    # Plot label
    axThreshold.set_ylabel('Threshold (dB SPL)', fontsize=fontSizeLabels)
    
    # Axis spacing and labels
    axThreshold.set_xticks(range(2))
    axThreshold.set_xlim([-0.5, 1.5])
    extraplots.set_ticks_fontsize(axThreshold, fontSizeTicks)
    axThreshold.set_xticklabels(['D1\n Median={:.2f}'.format(thresholdMedD1), 
                                 'nD1\n Median={:.2f}'.format(thresholdMednD1)])
    
    plt.sca(axThreshold)
    spacing = 0.01 # Value for point spacing 
    
    # Plots threshold for nD1 cells with a median line
    markers = extraplots.spread_plot(1, thresholdnD1, spacing)
    plt.setp(markers, color=colornD1)
    axThreshold.plot([-.1,.1], [thresholdMedD1, thresholdMedD1], color='black', lw=10)
    
    # Plots threshold for D1 cells with a median line
    markers = extraplots.spread_plot(0, thresholdD1, spacing)
    plt.setp(markers, color=colorD1)
    axThreshold.plot([.9,1.1], [thresholdMednD1, thresholdMednD1], color='black', lw=10)
    
    extraplots.boxoff(axThreshold) # Removes box around plot

# ========================== Rate Descrimination Accuracy ==========================

if RATEDESCRIM:
    
    onsetdb = db.query('tuningResponseRatio > {}'.format(latencyRatio))
    onsetdb = onsetdb.query('tuningResponseRate > {}'.format(latencyRate))   
    # onsetdb = db
    
    # Seperates database into D1 and nD1 cells
    onsetD1db = onsetdb.query(studyparams.D1_CELLS) # D1 cells
    onsetnD1db = onsetdb.query(studyparams.nD1_CELLS) # nD1 cells
    
    # Creates array of onset to sustained ratio values for each cell group
    onsetD1 = onsetD1db['cfOnsetivityIndex']
    onsetnD1 = onsetnD1db['cfOnsetivityIndex']
    
    zStat, pVal = stats.mannwhitneyu(onsetnD1, onsetD1, alternative='two-sided')
    
    plt.text(2.8, 8, 'pVal = {:.2f}'.format(pVal))
    
    # Filters out any non-number values
    onsetD1 = onsetD1[onsetD1*0 == 0]
    onsetnD1 = onsetnD1[onsetnD1*0 == 0]
    
    # Takes median of D1 and nD1 onset to sustained ratios
    onsetMedD1 = np.median(onsetD1)
    onsetMednD1 = np.median(onsetnD1)
    
    # Plot label
    axOnset.set_ylabel('Onset to sustained ratio', fontsize=fontSizeLabels)
    
    # X-axis scaling and labels 
    axOnset.set_xticks(range(2))
    axOnset.set_xlim([-0.5, 1.5])
    axOnset.set_ylim([-0.51, 1.1])
    extraplots.set_ticks_fontsize(axOnset, fontSizeTicks)
    axOnset.set_xticklabels(['D1\n Median={:.2f}'.format(onsetMedD1), 
                             'nD1\n Median={:.2f}'.format(onsetMednD1)])
    
    # Plots onset to sustained ratio for nD1 cells with a median line
    pos = jitter(np.ones(len(onsetnD1))*1, dotSpread)
    axOnset.plot(pos, onsetnD1, '.', color=colornD1)
    axOnset.plot([.8,1.2], [onsetMednD1, onsetMednD1], color='black', lw=4, alpha=0.6)
    
    # Plots onset to sustained ratio for D1 cells with a median line
    pos = jitter(np.ones(len(onsetD1))*0, dotSpread)
    axOnset.plot(pos, onsetD1, '.', color=colorD1)
    axOnset.plot([-.2,.2], [onsetMedD1, onsetMedD1], color='black', lw=4, alpha=0.6)
    
    extraplots.boxoff(axOnset) # Removes box around plot 

# ========================== Phase Descrimination Accuracy ==========================
    
if PHASEDECRIM:
    print('Hello')

# ========================== Saving ==========================

extraplots.save_figure(figFilename, 'pdf', figSize, outputDirectory)
plt.show()