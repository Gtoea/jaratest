# -*- coding: utf-8 -*-
"""
This script takes the database generated by database_generation_test.py and plots figures to compare D1 and nD1 cells. 

This script plots:
1. Latency

Created on Wed Oct 21 12:22:30 2020
@author: Devin Henderling
"""

import os
import figparams
import studyparams
import numpy as np
from jaratoolbox import celldatabase
from jaratoolbox import settings
from jaratoolbox import extraplots
from matplotlib import pyplot as plt
import matplotlib.gridspec as gridspec
from scipy import stats

# ========================== Utility Functions ==========================

np.random.seed(7) # Seed for jitter function

# Creates variation in point spacing
def jitter(arr, dotSpread):
    jitter = (np.random.random(len(arr))-0.5)*dotSpread
    jitteredArr = arr + jitter
    return jitteredArr

dotSpread = 0.2 # Value for spread of points on figures (higher value equals greater spread) 

# ========================== Run Mode ==========================

# Set to 1 to run for one test animal, set to 0 to run for all animals in study 
ONE_SUBJECT = 0

if ONE_SUBJECT:
    d1mice = studyparams.SINGLE_MOUSE
    outputDir = os.path.join(settings.TEST_PATH, studyparams.STUDY_NAME, 'figures') 
    pathtoDB = os.path.join(settings.TEST_PATH, studyparams.STUDY_NAME,
                            '{}_0.75.h5'.format(d1mice[0]))
    figFilename = 'figure_{}'.format(d1mice[0])
else:
    d1mice = studyparams.ASTR_D1_CHR2_MICE
    outputDir = os.path.join(settings.TEST_PATH, studyparams.STUDY_NAME, 'figures') 
    pathtoDB = os.path.join(settings.TEST_PATH, studyparams.STUDY_NAME, 
                            '{}.h5'.format(studyparams.DATABASE_NAME))
    figFilename = 'figure_{}'.format(studyparams.DATABASE_NAME)

# A value of 1 plots the given comparison, 0 does not 
LATENCY = 1 # Time of response relative to stimulus
BW10 = 1 # bandwidth of response 10 decibels above threshold response
THRESHOLD = 1 # Lowest amplitude of response at the characteristic frequency
ONSET = 1 # Ratio of response after stimulus between onset (0-50ms) and sustained (50-100ms) periods

# examples = [27, 29, 51, 58, 682, 798, 1065]

# Loads database for plotting 
cellDB = celldatabase.load_hdf(pathtoDB)

# ========================== Figure Parameters ========================== 

# Figure size
figSize = [12, 8] 

# Colors 
colorD1 = figparams.colors['D1']
colornD1 = figparams.colors['nD1']

# Font size
fontSizeLabels = figparams.fontSizeLabels*2
fontSizeTicks = fontSizeLabels*0.5
fontSizePanel = figparams.fontSizePanel*2
fontSizeTitles = figparams.fontSizeTitles*2

# Clears the figure
fig = plt.gcf()
fig.clf()

# creates gridspec object and sets spacing 
gs = gridspec.GridSpec(1, 10)
gs.update(left=0.04, right=0.98, top=0.95, bottom=0.175, wspace=1.1, hspace=0.5)

# Creates axes objects for each plot
axLatency = plt.subplot(gs[0, 0:2])
axBW10 = plt.subplot(gs[0, 2:4])
axBW10Zoomed = plt.subplot(gs[0, 4:6])
axThreshold = plt.subplot(gs[0, 6:8])
axOnset = plt.subplot(gs[0, 8:10])

# ========================== Latency ==========================

if LATENCY:
    # Filters for cells with a sufficient response 
    latencyDB = cellDB.query('tuningOnsetRate>7')
    
    # Seperates database into D1 and nD1 cells
    latencyD1DB = latencyDB.query(studyparams.D1_CELLS) # D1 cells
    latencynD1DB = latencyDB.query(studyparams.nD1_CELLS)
    
    # Creates array of latencies in milliseconds for each cell group 
    latencyD1 = latencyD1DB['latency'] * 1000 # latency of each D1 cell in milliseconds
    latencynD1 = latencynD1DB['latency'] * 1000 # latency of each nD1 cell in milliseconds
    
    # Calculates the median of the D1 and nD1 latencies 
    latencyMedD1 = latencyD1.median() # Median of D1 cell latency
    latencyMednD1 = latencynD1.median() # Median of nD1 cell latency
    
    # Calculates statistics for latency between cell type
    latencyzstat, latencypVal = stats.mannwhitneyu(latencynD1, latencyD1, alternative='two-sided')

    # Places Pval on plot 
    plt.text(-10.75, 1, 'pVal = {:.2f}'.format(latencypVal))
    
    # Plot label
    axLatency.set_ylabel('Latency (ms)', fontsize=fontSizeLabels)
        
    # Axis spacing and labels 
    axLatency.set_xticks(range(2))
    axLatency.set_xticklabels(['D1\n Median={:.2f} \n n={}'.format(latencyMedD1, len(latencyD1)), 
                               'nD1\n Median={:.2f} \n n={}'.format(latencyMednD1,
                                                                    len(latencynD1))])
    axLatency.set_xlim([-0.5, 1.5])
    # y-axis tick limits # To make graph look cleaner if verified no points below zero 
    # axLatency.set_ylim([0, 80])
    extraplots.set_ticks_fontsize(axLatency, fontSizeTicks) # Axis tick fontsize
    
    # plots latency of nD1 cells with a median line
    pos = jitter(np.ones(len(latencynD1))*1, dotSpread)
    axLatency.plot(pos, latencynD1, '.', color=colornD1)
    axLatency.plot([.85,1.15], [latencyMednD1, latencyMednD1], color='black', lw=4, alpha=0.6) 
    
    # Plots latency of D1 cells with a median line
    pos = jitter(np.ones(len(latencyD1))*0, dotSpread)
    axLatency.plot(pos, latencyD1, '.', color=colorD1)
    axLatency.plot([-.15,.15], [latencyMedD1, latencyMedD1], color='black', lw=4, alpha=0.6)
    
    # Removes box around entire plot 
    extraplots.boxoff(axLatency)  

# ========================== BW10 ==========================

if BW10:  
    # Seperates database into D1 and nD1 cells
    BW10D1DB = cellDB.query(studyparams.D1_CELLS) # D1 cells
    BW10nD1DB = cellDB.query(studyparams.nD1_CELLS) # nD1 cells
    
    # Creates array of BW10 values for each cell group
    BW10D1 = BW10D1DB["bw10"]
    BW10nD1 = BW10nD1DB["bw10"]
    
    # Calculates the median of the D1 and nD1 BW10
    BW10MedD1 = BW10D1.median() # Median of D1 cell BW10
    BW10MednD1 = BW10nD1.median() # Median of nD1 cell BW10
    
    # Calculates statistics for BW10 between cell types 
    BW10zstat, BW10pVal = stats.mannwhitneyu(BW10nD1, BW10D1, alternative='two-sided')
    
    # Places Pval on plot 
    plt.text(-8, 1, 'pVal = {:.2f}'.format(BW10pVal))
    
    # Plot label 
    axBW10.set_ylabel('BW10', fontsize=fontSizeLabels)
    
    # Axis spacing and labels  
    axBW10.set_xticks(range(2))
    axBW10.set_xticklabels(['D1\n Median={:.2f} \n n={}'.format(BW10MedD1, len(BW10D1)),
                            'nD1\n Median={:.2f} \n n={}'.format(BW10MednD1, len(BW10nD1))]) 
    axBW10.set_xlim([-0.5, 1.5]) 
    extraplots.set_ticks_fontsize(axBW10, fontSizeTicks) # Sets tick fontsize
    
    # Plots BW10 for nD1 cells with a median line
    pos = jitter(np.ones(len(BW10nD1))*1, dotSpread)
    axBW10.plot(pos, BW10nD1, '.', color=colornD1)
    axBW10.plot([.85,1.15], [BW10MednD1, BW10MednD1], color='black', lw=4, alpha=0.6)
    
    # Plots BW10 for D1 cells with a median line
    pos = jitter(np.ones(len(BW10D1))*0, dotSpread)
    axBW10.plot(pos, BW10D1, '.', color=colorD1)
    axBW10.plot([-.15,.15], [BW10MedD1, BW10MedD1], color='black', lw=4, alpha=0.6) 
    
    extraplots.boxoff(axBW10) # Removes box around plot
   
# ========================== BW10 Zoomed ==========================
    
    # Plot label
    axBW10Zoomed.set_ylabel('BW10 Zoomed-in', fontsize=fontSizeLabels)
    
    # Axis spacing and labels  
    axBW10Zoomed.set_xticks(range(2)) # x-axis tick positioning 
    axBW10Zoomed.set_xticklabels(['D1\n Median={:.2f}'.format(BW10MedD1), 
                                  'nD1\n Median={:.2f}'.format(BW10MednD1)])
    axBW10Zoomed.set_xlim([-0.5, 1.5]) # x-axis tick limits 
    axBW10Zoomed.set_ylim([0, 1.5]) # y-axis tick limits 
    extraplots.set_ticks_fontsize(axBW10Zoomed, fontSizeTicks) # Sets tick fontsize
    
    # Plots BW10 zoomed for nD1 cells with a median line
    pos = jitter(np.ones(len(BW10nD1))*1, dotSpread*2)
    axBW10Zoomed.plot(pos, BW10nD1, '.', color=colornD1)
    axBW10Zoomed.plot([.80,1.20], [BW10MednD1, BW10MednD1], color='black', lw=4, alpha=0.6)
    
    # Plots BW10 zoomed for D1 cells with a median line
    pos = jitter(np.ones(len(BW10D1))*0, dotSpread*2)
    axBW10Zoomed.plot(pos, BW10D1, '.', color=colorD1)
    axBW10Zoomed.plot([-.20,.20], [BW10MedD1, BW10MedD1], color='black', lw=4, alpha=0.6)
    
    extraplots.boxoff(axBW10Zoomed) # Removes box around plot
    
# ========================== Threshold ==========================

if THRESHOLD:
    # Seperates database into D1 and nD1 cells
    thresholdD1DB = cellDB.query(studyparams.D1_CELLS) # D1 cells
    thresholdnD1DB = cellDB.query(studyparams.nD1_CELLS) # nD1 cells
    
    # Creates array of threshold values for each cell group
    thresholdD1 = thresholdD1DB['thresholdFRA']
    thresholdnD1 = thresholdnD1DB['thresholdFRA']
    
    # Takes median of D1 and nD1 thresholds
    thresholdMedD1 = thresholdD1.median()
    thresholdMednD1 = thresholdnD1.median()
    
    # Plot label
    axThreshold.set_ylabel('Threshold (dB SPL)', fontsize=fontSizeLabels)
    
    # Axis spacing and labels
    axThreshold.set_xticks(range(2))
    axThreshold.set_xlim([-0.5, 1.5])
    extraplots.set_ticks_fontsize(axThreshold, fontSizeTicks)
    axThreshold.set_xticklabels(['D1\n Median={:.2f}'.format(thresholdMedD1), 
                                 'nD1\n Median={:.2f}'.format(thresholdMednD1)])
    
    plt.sca(axThreshold)
    spacing = 0.05 # Value for point spacing 
    
    # Plots threshold for nD1 cells with a median line
    markers = extraplots.spread_plot(1, thresholdnD1, spacing)
    plt.setp(markers, color=colornD1)
    axThreshold.plot([-.1,.1], [thresholdMedD1, thresholdMedD1], color='black', lw=10)
    
    # Plots threshold for D1 cells with a median line
    markers = extraplots.spread_plot(0, thresholdD1, spacing)
    plt.setp(markers, color=colorD1)
    axThreshold.plot([.9,1.1], [thresholdMednD1, thresholdMednD1], color='black', lw=10)
    
    extraplots.boxoff(axThreshold) # Removes box around plot

# ========================== Onset to Sustained Ratio ==========================

if ONSET:
    
    # Seperates database into D1 and nD1 cells
    onsetD1DB = cellDB.query(studyparams.D1_CELLS) # D1 cells
    onsetnD1DB = cellDB.query(studyparams.nD1_CELLS) # nD1 cells
    
    # Creates array of onset to sustained ratio values for each cell group
    onsetD1 = onsetD1DB['cfOnsetivityIndex']
    onsetnD1 = onsetnD1DB['cfOnsetivityIndex']
    
    # Filters out any non-number values
    onsetD1 = onsetD1[onsetD1*0 == 0]
    onsetnD1 = onsetnD1[onsetnD1*0 == 0]
    
    # Takes median of D1 and nD1 onset to sustained ratios
    onsetMedD1 = np.median(onsetD1)
    onsetMednD1 = np.median(onsetnD1)
    
    # Plot label
    axOnset.set_ylabel('Onset to sustained ratio', fontsize=fontSizeLabels)
    
    # X-axis scaling and labels 
    axOnset.set_xticks(range(2))
    axOnset.set_xlim([-0.5, 1.5])
    axOnset.set_ylim([-0.51, 1.1])
    extraplots.set_ticks_fontsize(axOnset, fontSizeTicks)
    axOnset.set_xticklabels(['D1\n Median={:.2f}'.format(onsetMedD1), 
                             'nD1\n Median={:.2f}'.format(onsetMednD1)])
    
    # Plots onset to sustained ratio for nD1 cells with a median line
    pos = jitter(np.ones(len(onsetnD1))*1, dotSpread)
    axOnset.plot(pos, onsetnD1, '.', color=colornD1)
    axOnset.plot([.8,1.2], [onsetMednD1, onsetMednD1], color='black', lw=4, alpha=0.6)
    
    # Plots onset to sustained ratio for D1 cells with a median line
    pos = jitter(np.ones(len(onsetD1))*0, dotSpread)
    axOnset.plot(pos, onsetD1, '.', color=colorD1)
    axOnset.plot([-.2,.2], [onsetMedD1, onsetMedD1], color='black', lw=4, alpha=0.6)
    
    extraplots.boxoff(axOnset) # Removes box around plot 

# ========================== Saving ==========================

extraplots.save_figure(figFilename, 'pdf', figSize, outputDir)
plt.show()